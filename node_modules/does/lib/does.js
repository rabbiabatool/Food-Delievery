// Generated by CoffeeScript 1.6.3
var colors, deferred, detect, getUuid, lastInstance, should;

deferred = require('also').deferred;

should = require('should');

colors = require('colors');

lastInstance = void 0;

module.exports = function(config) {
  var local, mode, rootContext, routes, seq;
  if (config == null) {
    config = {};
  }
  mode = ((function() {
    try {
      return config.does.mode;
    } catch (_error) {}
  })()) || 'spec';
  seq = 0;
  rootContext = this;
  if (mode === 'spec') {
    lastInstance = local = {
      mode: mode,
      entities: {},
      /*
      
      
      `local.entities` - Houses spectated entites
      -------------------------------------------
      
      Storage Structure
      
      ```
      
      entities/:uuid:/uuid           # * Yip
      entities/:uuid:/createdAt      # * Timestamp
      entities/:uuid:/object         # * Reference to object
      entities/:uuid:/name           # * Name
      entities/:uuid:/type           # * Constructor name (if present) ##undecided
      entities/:uuid:/tagged         # * Is a special case entity
      entities/:uuid:/functions      # * List of function expectations
      entities/:uuid:/spectator      # * Spectator function name (does or $does)
      
      entities/:uuid:/functions/fnName/original       # * Container for the original function
      entities/:uuid:/functions/fnName/original/fn    # * Reference to the original function
      
      entities/:uuid:/functions/fnName/expects    # * Array of mock function containers
      ```
      
      * Currently only the first mock in the array is used
      * Later it should switch to the second upon calling the first to allow more than 
        one mock to be set up in a sequece
      
      ```
      entities/:uuid:/functions/fnName/expects/0/expectation  # * Boolean - reject if not called in test
      entities/:uuid:/functions/fnName/expects/0/active       # * Boolean - true if the expectation is active
      entities/:uuid:/functions/fnName/expects/0/creator      # * Ref to creator (test or hook)
      entities/:uuid:/functions/fnName/expects/0/called       # * Boolean - was it called
      entities/:uuid:/functions/fnName/expects/0/count        # * (temporary) - count of calls
      entities/:uuid:/functions/fnName/expects/0/break        # * (later) - sets a breakpoint - COMPLEXITIES: test timeouts, runs respawn new process
      entities/:uuid:/functions/fnName/expects/0/stub         # * The stub function (wrapper)
      entities/:uuid:/functions/fnName/expects/0/spy          # * Boolean - should it call onward to origal function 
      entities/:uuid:/functions/fnName/expects/0/fn           # * The function mocker
      
      ```
      
      * The stub function (wrapper) substitutes the real function on the ""live"" object 
      * It calls the mocker as assigned by `object.does fnName: -> 'this fn is the mocker'`
      * It then calls the original if spy is true
      
      entities/:uuid:/properties  # later
      */

      tagged: {},
      /*
      
      
      `local.tagged` - Special case (designer) entities
      -------------------------------------------------
      
      * for spectated objcts that span the entire run (not flushed at each it)
      * see also ipso.save() https://github.com/nomilous/ipso/commit/d73f6ec3df301201429a69df4d11fc984d5d75d3
      
      tagged/:tag:/object -> entities/:uuid: (where tagged is true)
      */

      originalFn: {
        context: void 0,
        fn: void 0
      },
      /*
      
      `local.originalFn` - !!EXPERIMENTAL!!
      -------------------------------------
      
      * reference to the original function for access within a running stub
      * assigned by each stub proxy at calltime
      * accessable via does.original()
      * only behaves correctly when called from within the stub
      * use from within a spy stub will cause a duplicate call
      */

      get: function(opts, callback) {
        var name;
        try {
          name = opts.query.tag;
        } catch (_error) {}
        if (name == null) {
          return callback(new Error("does.get(opts) requires opts.query.tag"));
        }
        if (local.tagged[name] == null) {
          return callback(new Error("does has nothing with tag " + name));
        }
        return callback(null, local.tagged[name].object);
      },
      getSync: function(opts) {
        var name;
        try {
          name = opts.query.tag;
        } catch (_error) {}
        name || (name = opts);
        if (name == null) {
          throw new Error("does.get(opts) requires opts.query.tag");
        }
        if (local.tagged[name] == null) {
          throw new Error("does has nothing with tag " + name);
        }
        return local.tagged[name].object;
      },
      config: function(opts) {
        var key, _results;
        _results = [];
        for (key in opts) {
          switch (key) {
            case 'mode':
              _results.push(local.mode = opts[key]);
              break;
            default:
              _results.push(void 0);
          }
        }
        return _results;
      },
      runtime: {
        active: false,
        holding: []
      },
      activate: function(runtime) {
        var ancestors, beforeAlls, hook, original, parent, rname, tapTimeout, _base, _base1, _i, _len, _ref;
        if (runtime.mode === 'bridge') {
          return;
        }
        local.runtime.current = runtime;
        rname = (_base = local.runtime).name || (_base.name = detect(rootContext));
        if (rname !== 'mocha') {
          return;
        }
        if (runtime.spec != null) {
          tapTimeout = function() {
            local.runtime.onTimeout = runtime.spec.timer._onTimeout;
            return runtime.spec.timer._onTimeout = function() {
              return local.assert(runtime.resolver).then(function() {
                return local.runtime.onTimeout.call(runtime.context);
              }, function(exception) {});
            };
          };
          tapTimeout();
          try {
            original = runtime.context.timeout;
          } catch (_error) {}
          try {
            runtime.context.timeout = function(ms) {
              original.call(runtime.context, ms);
              return tapTimeout();
            };
          } catch (_error) {}
        }
        if (((function() {
          try {
            return runtime.spec.type === 'test';
          } catch (_error) {}
        })())) {
          local.runtime.active = true;
          beforeAlls = [];
          ancestors = (_base1 = local.runtime).ancestors || (_base1.ancestors = []);
          ancestors.length = 0;
          parent = runtime.spec.parent;
          while (parent != null) {
            _ref = parent._beforeAll;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              hook = _ref[_i];
              beforeAlls.push(hook);
            }
            ancestors.unshift(parent);
            parent = parent.parent;
          }
          return local.runtime.holding.map(function(_arg) {
            var expects, functionName, functions, object, uuid, _ref1, _ref2;
            uuid = _arg.uuid, functionName = _arg.functionName;
            _ref1 = local.entities[uuid], object = _ref1.object, functions = _ref1.functions;
            _ref2 = functions[functionName], expects = _ref2.expects, original = _ref2.original;
            if (beforeAlls.indexOf(expects[0].creator) >= 0) {
              return;
            }
            if (original.fn != null) {
              object[functionName] = original.fn;
            } else {
              delete object[functionName];
            }
            return delete functions[functionName];
          });
        } else if (((function() {
          try {
            return runtime.spec.type === 'hook';
          } catch (_error) {}
        })())) {
          return local.runtime.active = true;
        } else {
          return local.runtime.active = false;
        }
      },
      spectate: deferred(function(action, opts, object) {
        var existing, name, newTitle, originalTitle, spectatorName, uuid;
        if (local.mode === 'bridge') {
          return action.resolve(object);
        }
        if (object == null) {
          return action.reject(new Error("does can't expect undefined to do stuff"));
        }
        name = opts.name;
        if (opts.tagged && (local.tagged[name] != null)) {
          try {
            object = local.tagged[name].object.object;
            originalTitle = object.title;
            newTitle = name;
            if (originalTitle === newTitle) {
              return action.resolve(object);
            }
          } catch (_error) {}
          return action.reject(Error("does can't reassign tag " + name));
        }
        spectatorName = (object.does != null) && (object.does.uuid == null) ? '$does' : 'does';
        if ((object.$ipso != null) && object.$ipso.PENDING) {
          opts.tagged = true;
        }
        if (uuid = getUuid(object)) {
          if (existing = local.entities[uuid]) {
            if (existing.name !== name) {
              return action.reject(new Error("does cannot rename '" + existing.name + "' to '" + name + "'"));
            }
            if (opts.tagged) {
              existing.tagged = true;
              local.tagged[name] = {
                object: existing
              };
            }
            return action.resolve(object);
          }
        }
        return (function(uuid) {
          var spectated;
          local.entities[uuid] = spectated = {
            uuid: uuid,
            createdAt: new Date,
            object: object,
            type: (function() {
              try {
                return object.constructor.name;
              } catch (_error) {}
            })(),
            name: name,
            tagged: opts.tagged || false,
            functions: {},
            spectator: spectatorName
          };
          if (opts.tagged) {
            local.tagged[name] = {
              object: spectated
            };
          }
          object[spectatorName] = function(expectations) {
            return local.does(uuid, object, expectations);
          };
          Object.defineProperty(object[spectatorName], 'uuid', {
            get: function() {
              return uuid;
            }
          });
          return action.resolve(object);
        })(++seq);
      }),
      spectateSync: function(opts, object) {
        var name, newTitle, originalTitle, spectatorName;
        if (local.mode === 'bridge') {
          return object;
        }
        if (object == null) {
          throw new Error("does can't expect undefined to do stuff");
        }
        name = opts.name;
        if (opts.tagged && (local.tagged[name] != null)) {
          try {
            object = local.tagged[name].object.object;
            originalTitle = object.title;
            newTitle = name;
            if (originalTitle === newTitle) {
              return object;
            }
          } catch (_error) {}
          throw new Error("does can't reassign tag " + name);
        }
        spectatorName = (object.does != null) && (object.does.uuid == null) ? '$does' : 'does';
        if ((object.$ipso != null) && object.$ipso.PENDING) {
          opts.tagged = true;
        }
        return (function(uuid) {
          var spectated;
          local.entities[uuid] = spectated = {
            uuid: uuid,
            createdAt: new Date,
            object: object,
            type: (function() {
              try {
                return object.constructor.name;
              } catch (_error) {}
            })(),
            name: name,
            tagged: opts.tagged || false,
            functions: {},
            spectator: spectatorName
          };
          if (opts.tagged) {
            local.tagged[name] = {
              object: spectated
            };
          }
          object[spectatorName] = function(expectations) {
            return local.does(uuid, object, expectations);
          };
          Object.defineProperty(object[spectatorName], 'uuid', {
            get: function() {
              return uuid;
            }
          });
          return object;
        })(++seq);
      },
      does: function(uuid, object, expectations) {
        var creator, fn, fnName, spy;
        if (!local.runtime.active) {
          console.log('does:', 'warning: ignored expectation declaration outside of ipso enabled hook or test scope'.yellow);
          return object;
        }
        creator = local.runtime.current.spec;
        if (creator.type === 'hook' && !creator.title.match(/before/)) {
          console.log('does:', 'warning: ignored expectation declaration in after hook'.yellow);
          return object;
        }
        for (fnName in expectations) {
          if (fnName.match(/^_/)) {
            fnName = fnName.slice(1);
            spy = true;
            fn = expectations["_" + fnName];
          } else {
            spy = false;
            fn = expectations[fnName];
          }
          local.expectFn({
            creator: creator,
            uuid: uuid,
            fnName: fnName,
            spy: spy,
            fn: fn
          });
        }
        return object;
      },
      reset: deferred(function(action) {
        var creator, entities, expectation, expects, functionName, functions, holding, name, object, original, uuid, _ref, _ref1, _ref2;
        entities = local.entities;
        local.runtime.holding.length = 0;
        holding = local.runtime.holding;
        for (uuid in entities) {
          _ref = entities[uuid], name = _ref.name, object = _ref.object, functions = _ref.functions;
          for (functionName in functions) {
            _ref1 = functions[functionName], expects = _ref1.expects, original = _ref1.original;
            _ref2 = expects[0], expectation = _ref2.expectation, creator = _ref2.creator;
            if (!expectation) {
              holding.push({
                functionName: functionName,
                uuid: uuid
              });
              continue;
            }
            if (original.fn != null) {
              object[functionName] = original.fn;
            } else {
              delete object[functionName];
            }
            expects[0].active = false;
          }
        }
        return action.resolve();
      }),
      expectFn: function(_arg) {
        var creator, entity, expect, expectation, expects, fn, fnName, functions, name, object, original, spectator, spy, stub, tagged, type, uuid, _ref;
        creator = _arg.creator, uuid = _arg.uuid, fnName = _arg.fnName, fn = _arg.fn, spy = _arg.spy;
        if (fnName === 'constructor') {
          fnName = '$constructor';
        }
        entity = local.entities[uuid];
        object = entity.object, name = entity.name, type = entity.type, tagged = entity.tagged, spectator = entity.spectator, functions = entity.functions;
        _ref = functions[fnName] || (functions[fnName] = {
          expects: [],
          original: {
            fn: object[fnName]
          }
        }), expects = _ref.expects, original = _ref.original;
        expectation = true;
        try {
          if (creator.type === 'hook') {
            if (!creator.title.match(/before each/)) {
              expectation = false;
            }
          }
        } catch (_error) {}
        if ((expects[0] != null) && expects[0].active) {
          if (!(creator.type === 'hook' && creator.title.match(/before all/))) {
            throw new Error("does doesn't currently support sequenced expectations - already stubbed [" + type + ": " + name + "]." + fnName + "()");
            return;
          }
        }
        if (expectation) {
          if (spy) {
            object[fnName] = stub = function() {
              /* EXPECTATION (spy)*/

              /* These are created only in tests or beforeEach hooks*/

              var error;
              local.originalFn.context = this;
              local.originalFn.fn = original.fn;
              expect.called = true;
              expect.count++;
              try {
                expect.fn.apply(this, arguments);
                if (original.fn != null) {
                  return original.fn.apply(this, arguments);
                }
              } catch (_error) {
                error = _error;
                if (error.name === 'AssertionError') {
                  return expect.error = error;
                } else {
                  throw error;
                }
              }
            };
          } else {
            object[fnName] = stub = function() {
              /* EXPECTATION (mocker)*/

              /* These are created only in tests or beforeEach hooks*/

              var error;
              local.originalFn.context = this;
              local.originalFn.fn = original.fn;
              expect.called = true;
              expect.count++;
              try {
                return expect.fn.apply(this, arguments);
              } catch (_error) {
                error = _error;
                if (error.name === 'AssertionError') {
                  return expect.error = error;
                } else {
                  throw error;
                }
              }
            };
          }
        } else {
          if (spy) {
            object[fnName] = stub = function() {
              /* STUB (spy)*/

              /* These are not created in tests or beforeEach hooks*/

              var error;
              local.originalFn.context = this;
              local.originalFn.fn = original.fn;
              expect.called = true;
              expect.count++;
              try {
                expect.fn.apply(this, arguments);
                if (original.fn != null) {
                  return original.fn.apply(this, arguments);
                }
              } catch (_error) {
                error = _error;
                if (error.name === 'AssertionError') {
                  return expect.error = error;
                } else {
                  throw error;
                }
              }
            };
          } else {
            object[fnName] = stub = function() {
              /* STUB (mocker)*/

              /* These are not created in tests or beforeEach hooks*/

              var error;
              local.originalFn.context = this;
              local.originalFn.fn = original.fn;
              expect.called = true;
              expect.count++;
              try {
                return expect.fn.apply(this, arguments);
              } catch (_error) {
                error = _error;
                if (error.name === 'AssertionError') {
                  return expect.error = error;
                } else {
                  throw error;
                }
              }
            };
          }
        }
        return expects[0] = expect = {
          expectation: expectation,
          active: true,
          creator: creator,
          called: false,
          error: void 0,
          count: 0,
          stub: stub,
          spy: spy,
          fn: fn
        };
      },
      assert: deferred(function(action, done) {
        var call, count, error, expect, expectation, expected, expects, fn, fnName, functions, name, object, original, resulted, spec, spectator, type, uuid, _ref, _ref1;
        if (done == null) {
          done = null;
        }
        if (local.mode === 'bridge') {
          return action.resolve();
        }
        spec = local.runtime.current.spec;
        if (spec.type !== 'test') {
          return action.resolve();
        }
        if (typeof done === 'function') {
          expected = {};
          resulted = {};
          for (uuid in local.entities) {
            _ref = local.entities[uuid], expectation = _ref.expectation, object = _ref.object, type = _ref.type, name = _ref.name, spectator = _ref.spectator, functions = _ref.functions;
            count = 0;
            for (fn in functions) {
              count++;
            }
            if (count === 0) {
              continue;
            }
            expected[name] = {
              functions: {}
            };
            resulted[name] = {
              functions: {}
            };
            for (fnName in functions) {
              _ref1 = functions[fnName], expects = _ref1.expects, original = _ref1.original;
              expect = expects[0];
              if (fnName === '$constructor') {
                call = "" + type + ".constructor()";
              } else {
                call = "" + type + "." + fnName + "()";
              }
              if (!expect.expectation) {
                expected[name].functions[call] = 'passive stub';
                resulted[name].functions[call] = 'passive stub';
                continue;
              }
              if (!expect.active) {
                continue;
              }
              if (expect.error != null) {
                if (expect.error.name === 'AssertionError') {
                  expected[name].functions[call] = {
                    AssertionError: {
                      'expected/actual': expect.error.actual
                    }
                  };
                  resulted[name].functions[call] = {
                    AssertionError: {
                      'expected/actual': expect.error.expected
                    }
                  };
                  continue;
                } else {
                  local.reset().then(function() {});
                  throw expect.error;
                }
              }
              expected[name].functions[call] = 'was called';
              if (expect.called) {
                resulted[name].functions[call] = 'was called';
              } else {
                resulted[name].functions[call] = 'was NOT called';
              }
            }
          }
          try {
            resulted.should.eql(expected);
          } catch (_error) {
            error = _error;
            return local.reset().then(function() {
              action.reject(error);
              return done(error);
            });
          }
        }
        return local.reset().then(function() {
          return action.resolve();
        });
      }),
      original: function(args) {
        var context, fn, _ref;
        if (args == null) {
          args = [];
        }
        _ref = local.originalFn, context = _ref.context, fn = _ref.fn;
        if (fn == null) {
          console.log('does:', 'warning: called original() from outside stub'.yellow);
          return;
        }
        return fn.apply(context, args);
      }
    };
  } else {
    throw new Error("does doesn't " + mode);
  }
  routes = {
    config: local.config,
    mode: local.mode,
    spectate: local.spectate,
    spectateSync: local.spectateSync,
    assert: local.assert,
    reset: local.reset,
    get: local.get,
    getSync: local.getSync,
    activate: local.activate,
    original: local.original
  };
  routes.get.$www = {};
  return routes;
};

detect = function(context) {
  if ((context.xit != null) && (context.xdescribe != null) && (context.xcontext != null)) {
    return 'mocha';
  }
  return 'bridge';
};

getUuid = function(object) {
  var error, uuid;
  try {
    return uuid = object.does.uuid;
  } catch (_error) {
    error = _error;
    try {
      return uuid = object.$does.uuid;
    } catch (_error) {}
  }
};

Object.defineProperty(module.exports, '_test', {
  enumerable: true,
  get: function() {
    var fn;
    fn = function() {
      return lastInstance;
    };
    fn.README = "\nThis `does._test()` exposes the entire internal structure of the \nmost recently created instance of a does spectation object.\n\nIt is intended for does' own internal testing.\n\nBE ADVISED! The structures may change drastically!\n\nOnce the design stabalizes a more formal interface for integration will be provided.\n\nThoughts, ideas and requests are welcome.\n";
    return fn;
  }
});

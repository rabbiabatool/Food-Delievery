// Generated by CoffeeScript 1.6.3
var activated, fs, lstatOverride, override, sep;

fs = require('fs');

sep = require('path').sep;

module.exports = function(list, opts) {
  var alias, moduleName, name, type, _results;
  if (opts == null) {
    opts = {};
  }
  module.exports.activate();
  type = 'literal';
  if (opts.aliases != null) {
    type = 'aliased';
  }
  _results = [];
  for (moduleName in list) {
    name = moduleName;
    alias = (function() {
      try {
        return opts.aliases[moduleName];
      } catch (_error) {}
    })();
    override[name] = {
      type: type,
      aliasPath: alias,
      'package.json': {
        name: name,
        version: '0.0.0',
        main: 'STUBBED.js',
        dependencies: {}
      },
      'STUBBED.js': list[moduleName]
    };
    if (type === 'literal') {
      _results.push(require(name));
    } else {
      _results.push(void 0);
    }
  }
  return _results;
};

override = {};

lstatOverride = {};

activated = false;

Object.defineProperty(module.exports, 'activate', {
  enumarable: 'false',
  get: function() {
    if (activated) {
      return function() {};
    }
    return function() {
      var lstatSync, readFileSync, statSync;
      activated = true;
      readFileSync = fs.readFileSync;
      fs.readFileSync = function(path, encoding) {
        /* MODIFIED BY ipso.define*/

        var file, mod, modulePath, modulesPath, parts, scriptPath, type, _ref;
        _ref = path.split(sep).slice(-2), mod = _ref[0], file = _ref[1];
        parts = path.split(sep).slice(0, -2);
        modulesPath = parts.join(sep);
        modulePath = parts.concat([mod]).join(sep);
        scriptPath = parts.concat([mod, 'STUBBED.js']).join(sep);
        if (override.hasOwnProperty(mod)) {
          type = override[mod].type;
          switch (file) {
            case 'package.json':
              lstatOverride[modulesPath] = 1;
              lstatOverride[modulePath] = 1;
              lstatOverride[scriptPath] = 1;
              return JSON.stringify(override[mod]['package.json']);
            case 'STUBBED.js':
              if (typeof override[mod]['STUBBED.js'] === 'function') {
                if (override[mod].type === 'aliased') {
                  return "module.exports = require('" + override[mod].aliasPath + "');";
                }
                if (override[mod].scriptPath != null) {
                  return "module.exports = require('" + override[mod].scriptPath + "');";
                } else {
                  override[mod].scriptPath = scriptPath;
                }
                return "ipso = require('ipso'); // testing catch 22\nmock = ipso.mock;\nMock = ipso.Mock;\nget  = function(tag) {\n\n    try { return ipso.does.getSync(tag).object }\n    catch (error) { console.log('ipso: missing mock \"%s\"', tag); }\n\n}; \n\nmodule.exports = " + ((function() {
                  switch (type) {
                    case 'literal':
                      return "(" + (override[mod]['STUBBED.js'].toString()) + ").call(this);";
                  }
                })());
              } else {
                console.log("ipso.define(list) requires list of functions to be exported as modules,\nor used as module factories.".red);
              }
          }
        }
        return readFileSync(path, encoding);
      };
      statSync = fs.statSync;
      fs.statSync = function(path) {
        /* MODIFIED BY ipso.define*/

        if (path.match(/STUBBED.js/)) {
          return {
            isDirectory: function() {
              return false;
            }
          };
        }
        return statSync(path);
      };
      lstatSync = fs.lstatSync;
      return fs.lstatSync = function(path) {
        /* MODIFIED BY ipso.define*/

        if (lstatOverride[path] != null) {
          return {
            isSymbolicLink: function() {
              return false;
            }
          };
        }
        return lstatSync(path);
      };
    };
  }
});

// Generated by CoffeeScript 1.6.3
var AssertionError, Does, Loader, config, deferred, does, facto, ipso, loadModules, loadModulesSync, parallel, should, util, _ref, _ref1;

_ref = require('also'), util = _ref.util, deferred = _ref.deferred, parallel = _ref.parallel;

AssertionError = require('assert').AssertionError;

facto = require('facto');

Loader = require('./loader');

Does = require('does');

does = Does({
  does: {
    mode: 'spec'
  }
});

should = require('should');

config = {
  dir: process.cwd(),
  modules: {}
};

_ref1 = Loader.create(config), loadModules = _ref1.loadModules, loadModulesSync = _ref1.loadModulesSync;

module.exports = ipso = function(actualTestFunction) {
  var testFunctionForMocha;
  return testFunctionForMocha = function(done) {
    var Module, arg1, argsToInjectIntoTest, fnArgsArray, testResolver, _i, _len, _ref2,
      _this = this;
    fnArgsArray = util.argsOf(actualTestFunction);
    argsToInjectIntoTest = [];
    if (done == null) {
      if (fnArgsArray[0] === 'done' || fnArgsArray[0] === 'facto') {
        console.log('ipso cannot inject done into describe() or context()'.red);
        return;
      }
      does.activate({
        context: this,
        mode: does.mode,
        spec: null,
        resolver: null
      });
      _ref2 = loadModulesSync(fnArgsArray, does);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        Module = _ref2[_i];
        argsToInjectIntoTest.push(Module);
      }
      actualTestFunction.apply(this, argsToInjectIntoTest);
      return;
    }
    does.activate({
      context: this,
      mode: does.mode,
      spec: this.test,
      resolver: done
    });
    testResolver = function(metadata) {
      return does.assert(done).then(function(result) {
        if (fnArgsArray[0] === 'facto') {
          facto(metadata);
        }
        return done();
      }, function(error) {
        if (fnArgsArray[0] === 'facto') {
          return facto(metadata);
        }
      }, function(notify) {});
    };
    if (fnArgsArray[0] === 'done' || fnArgsArray[0] === 'facto') {
      argsToInjectIntoTest.push(testResolver);
      arg1 = fnArgsArray.shift();
    }
    return loadModules(fnArgsArray, does).then(function(Modules) {
      var error, promise, _j, _len1;
      for (_j = 0, _len1 = Modules.length; _j < _len1; _j++) {
        Module = Modules[_j];
        argsToInjectIntoTest.push(Module);
      }
      try {
        promise = actualTestFunction.apply(_this, argsToInjectIntoTest);
      } catch (_error) {
        error = _error;
        does.reset().then(function() {
          return done(error);
        });
        return;
      }
      if (arg1 !== 'done' && arg1 !== 'facto') {
        try {
          if ((promise.then != null) && _this.test.type === 'test') {
            return does.reset().then(function() {
              return done(new Error('Synchronous test returned promise. Inject test resolver (done or facto).'));
            });
          }
        } catch (_error) {}
        testResolver();
        return;
      }
      try {
        if (promise.then != null) {
          return promise.then((function() {}), function(error) {
            return does.reset().then(function() {
              return done(error);
            });
          });
        }
      } catch (_error) {}
    }, function(error) {
      return does.reset().then(function() {
        return done(error);
      });
    });
  };
};

ipso.ipso = ipso;

ipso.mock = function(name) {
  var object;
  object = {
    title: name,
    is: function(mock) {
      if (typeof mock === 'object') {
        return object.should.equal(mock);
      }
      return name.should.equal(mock);
    },
    "with": function(list) {
      var key;
      for (key in list) {
        object[key] = list[key];
      }
      return object;
    }
  };
  return does.spectateSync({
    name: name,
    tagged: true
  }, object);
};

ipso.Mock = function(name) {
  var klass, mockObject;
  mockObject = ipso.mock(name);
  return klass = (function() {
    _Class["with"] = function() {
      mockObject["with"].apply(this, arguments);
      return klass;
    };

    function _Class() {
      var stub, stubs;
      stubs = does.getSync(name).object;
      if (typeof stubs.$constructor === 'function') {
        stubs.$constructor.apply(this, arguments);
      }
      for (stub in stubs) {
        if (stub === '$constructor') {
          continue;
        }
        this[stub] = stubs[stub];
      }
    }

    return _Class;

  })();
};

ipso.tag = deferred(function(action, list) {
  var tag;
  return parallel((function() {
    var _results;
    _results = [];
    for (tag in list) {
      _results.push((function(tag) {
        return function() {
          return does.spectateSync({
            name: tag,
            tagged: true
          }, list[tag]);
        };
      })(tag));
    }
    return _results;
  })()).then(action.resolve, action.reject, action.notify);
});

Object.defineProperty(ipso, 'original', {
  get: function() {
    return does.original;
  }
});

ipso.does = does;

ipso.define = require('./define');

ipso.components = require('./components')(ipso);

ipso.inject = ipso.components;

module.exports.once = function(fn) {
  return (function(done) {
    return function() {
      if (done) {
        return;
      }
      done = true;
      return fn.apply(this, arguments);
    };
  })(false);
};
